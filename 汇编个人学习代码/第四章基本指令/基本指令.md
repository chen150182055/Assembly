---

---

# 基本指令

#### 4.1简介

- 本章讲解基本汇编指令以供编写简单程序
- 算数运算
- 如何正确使用数据
- 如何根据字节偏移量来手动访问内存中某个位置上的数据
- 如何创建数组
- 如何运用指针

| 操作数 | 描述                            |
| ------ | ------------------------------- |
| L      | 字面值（Literal，或者说立即值） |
| M      | 内存（memory ，或者说变量）     |
| R      | 寄存器（Register）              |

#### 4.2 数据的移动和算数运算



###### 4.2.1移动数据

- 用汇编语言程序来开发程序时尤其需要在寄存器与内存之间移动数据。

  - 用来完成这项操作的是MOV指令

  - 该指令会把数据从源地点复制代目标地点。

  - NASM

    ```assembly
    MOV M/R, L/M/R     ;MOV eax, sum
    ```

  - 上面的例子就是把sum 移动到eax寄存器中

- MOV指令的具体要求

  1. 两个操作数的大小必须相同

  2. 两个操作数不能全是内存操作数（也就是说要想在两个内存操作数之间移动数据，必须用寄存器做中介）

  3. 指令指针寄存器（ip/eip/rip）不能用作目标操作数

     - 有一种特殊情况，是令两个位置上的数据彼此互换。这项需求可以用MOV指令实现，但是不能直接移动，而是需要一个中间寄存器。但是可以使用XCHG指令一步到位

       NASM

       ```assembly
       XCHG SIZE [M]/R, [M]/R   ;XCHG DWORD [sum], edx
       ```

     - 和MOV类似，XCHG指令的两个操作数也不能全都是内存操作数

###### 4.2.2 加法与减法

- INC与DEC指令可以操作内存操作数（变量）或者寄存器。这两个操作数的目标就是给操作数加1或者减1

  NASM

  ```assembly
  INC M/R		;INC sum
  DEC M/R		;DEC eax	
  ```

- 注意：NASM对待变量的方法很像C中的指针，如果直接写出变量名本身，那么它会将其视为内存地址。如果想引用该地址中的内容，则需要用方括号给变量解引用如[sum] 

- ADD和SUB指令可以用字面量来做减法，也可以用内存或者寄存器中的值来计算

  NASM

  ```assembly
  ;dest, src
  ADD SIZE [M]/R, L/[M]/R		;ADD WORD [sum], 50
  SUB SIZE [M]/R, L/[M]/R		;SUB eax, [val]
  ```

- NEG指令：可以切换操作数的正负号，也就是对操作数求补

  NASM

  ```assembly
  NEG SIZE [M]/R  	;NEG BYTE [sum]
  ```

  书本例子

  ```assembly
  SECTION .data 
  sum: DQ 0	;创建sum和val两个32位变量并为其指定初始值位0和25
  val: DQ 25
  
  SECTION .text 
  global _main
  _main:
  
  mov rax, 0 	;将rax寄存器设为0
  inc rax	;将rax寄存器加1
  add rax, 200 	;把十进制的字面量200加到rax当前的值中，并将结果保存到rax中
  sub rax, [val]	;从寄存器rax的值中减去变量val的值，并将结果保存在rax中
  mov [sum], rax	;把rax的值存放到变量sum中 
  dec QWORD [sum] ;给变量减1		 
  neg QWORD [sum] ;对变量求补
  
  mov rax, 60
  xor rdi, rdi
  syscall
  ```

###### 4.2.3 乘法和除法

- 乘除法要比加减法复杂一些

- 注意x86汇编中，操作数的个数取决与指令所针对的数据是否带符号

- MUL指令用来给<font color=red>无符号整数</font>执行乘法

  1. 被乘数保存在与乘数尺寸相对应的累加寄存器中（例如8位乘法的被乘数保存在8位的al寄存器里）

  2. 积的保存位置也无需手动指定，因为这是由MUL指令自动指定的

     | 乘数    | 被乘数 | 积      |
     | ------- | ------ | ------- |
     | M8/R8   | al     | ax      |
     | M16/R16 | ax     | dx:ax   |
     | M32/R32 | eax    | edx:eax |
     | M64/R64 | rax    | rdx:rax |

  3. 被乘数与积的存放地点都是根据乘数的尺寸来默认指定的

     NASM

     ```assembly
     MUL SIZE [M]/R    ;MUL DWORD [sum]
     ```

- IMUL指令用来给<font color=red>带符号的整数</font>执行乘法

  1. 该指令也有单操作数的版本

  2. 与MUL的主要区别在于它还有双操作数及3操作数的版本

  3. 双操作数版本和ADD及SUB指令类似，也就是会把这两个操作数都当成运算的源数据，并且要将其中一个操作数用作运算的目标，以便存放计算结果。

  4. 如果不想让IMUL指令把这个值覆盖掉，那么可以使用三操作数的版本，该版本要求开发者指出乘数、被乘数与积的位置。

     NASM

     ```assembly
     IMUL SIZE [M]/R     	;IMUL DWORD [sum]
     IMUL R, L/[M]/R			;IMUL ax, [val]
     IMUL R, [M]/R, L			;IMUL eax, [val], 10
     ```

- 除法也有无符号和带符号两种

- 会将结果以商与除数的形式分别保存

  | 除数    | 被除数  | 商   | 余数 |
  | ------- | ------- | ---- | ---- |
  | M8/R8   | ax      | al   | ah   |
  | M16/R16 | dx:ax   | ax   | dx   |
  | M32/R32 | edx:eax | eax  | edx  |
  | M64/R64 | rdx:rax | rax  | rdx  |
  |         |         |      |      |

- 使用DIV指令的时候只需要指定除数就可以了（分母），被除数（分子）需要提前加载到与除数尺寸想对应的寄存器里(上表)

- 如果被除数的值单用ax就能装得下，但规则要求必须用dx:ax合起来表示，那么被除数的正负号就要在高位寄存器里体现出来

  NASM

  ```assembly
  DIV SIZE [M]/R		;DIV DWORD [sum]
  ```

- 带符号整数用IDIV指令来相除

  - 没有双操作数和三操作数版本

  NASM

  ```assembly
  IDIV SIZE [M]/R		;IDIV DWORD [sum]
  ```

###### 4.2.4 移位

- 有一种更快地执行乘除法的操作，就是移位（因为处理器是把值当成一系列二进制位来处理的）

- 左移位指令SHL和右移位指令SHR 

  - 可以把内存操作数或寄存器中的值移动一定的位数

    NASM

    ```assembly
    SHL SIZE [M]/R, L	;SHL DWORD [val], 2
    SHR SIZE [M]/R, L	;SHR ebx, 1
    ```

  - 以上所述的位移位是逻辑移位，这会令二进制位出现在存储范围之外，无符号的数据通常是可以做逻辑移位运算的，然而若是对带符号的数据做逻辑移位，则可能破坏其内容

- 算数移位指令可以保留带符号整数的符号位

  - SAL是算数左移SAR是算数右移

    | 指令              | 二进制形式的结果 | 十进制形式的结果 |
    | ----------------- | ---------------- | ---------------- |
    | SAL WORD [val], 2 | 10000000         | -128             |
    | SAR WORD [val], 2 | 11111000         | -8               |

- ​	SAL和SAR的语法跟对应的逻辑移位指令类似，都是将内存操作数或寄存器中的值移动一定的位数，这个位数也可以用字面量来指定

  NASM

  ```assembly
  SAL SIZE [M]/R, L		;SAL DWORD [val], 2
  SAR SIZE [M]/R, L		;SAR ebx, 1
  ```

###### 4.2.5 处理负值

- 接下来专门谈论带符号的数值
- 执行任何算数指令之前，都必须确保相关的数值及其符号是正确的，而且要将它放在合适的寄存器中
- 各种汇编器都允许开发者把负值简单地保存到寄存器或变量中。这些值会自动以补码形式存放

